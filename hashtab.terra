C = terralib.includec("stdio.h")
C1 = terralib.includec("stdlib.h")
ffi = require("ffi")
local hashfunctions = terralib.includecstring [[	
unsigned long djb2hash(const char *str)
{
    unsigned long hash = 5381;
    int c;
    while ( (c = *str++))
        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
    return hash;
}
		 ]]

terra djb2hash(a : &int8) : uint64
   var hash =  5381ULL
   var c = @a
   var i :int8 = 0 -- typing makes a difference
   while c~=0 do
      hash = (( hash << 5)+hash) + c
      i = i+1
      c = @(a + i)
   end
   return hash
end

local function ptable(w)
   for key,value in pairs(w) do print(key,value) end
end

function makeHash(kType,vType,hashfunction)
   local b = {}
   local function add(self,key,value)
      b[hashfunction(key)] = {key,value}
   end
   local function exists(self,key)
      if b[hashfunction(key)]~= nil then
   	 return true
      else
   	 return false
      end
   end
   local function get(self,key)
      return terralib.cast(vType,b[hashfunction(key)][2])
   end
   local function delete(self,key)
      b[hashfunction(key)] = nil
   end
   local struct Hash   {   }
   Hash.methods.add =  terralib.cast( {&Hash,kType,vType} -> {}, add)
   Hash.methods.get = terralib.cast( {&Hash,kType} -> {vType}, get)
   Hash.methods.exists  = terralib.cast( {&Hash,kType} -> {bool}, exists)
   Hash.methods.del = terralib.cast( {&Hash,kType} -> {}, delete)
   local struct Iterator {_placeholder:uint8 }
   local ck,cuk,vk
   Iterator.methods.initialize = function()
      ck =  next(b,nil)
      cuk, vk = unpack(b[hashfunction(ck)])
   end
   Iterator.methods.hasNext = terralib.cast({&Iterator}->bool,function(self)
   					       if ck ~= nil then
   						  return(true)
   					       else
   						  ck = next(b,nil)
   						  return(false)
   					       end
   					  end)
   local tk = terralib.cast({}->kType,function()
   			       local currentk = cuk
   			       ck = next(b,ck)
			       if ck then 
				  cuk, vk = unpack(b[hashfunction(ck)])
			       end
   			       return currentk
   				      end)
   local tv = terralib.cast({}->vType,function() return  vk end)
   terra Iterator:next()
      return tv(),tk()
   end
   terra Hash:makeIter()
      var f:Iterator
      f:initialize()
      return f
   end
      
   return Hash
end

struct ComplexName
{
   name: &int8;
   x : double;
   y : double;
}

function strhash(s )
   -- return tonumber(hashfunctions.djb2hash(s))
   return tonumber(djb2hash(s))
end

hashStrToComplex = makeHash(rawstring, &ComplexName,strhash)
hashIntToComplex = makeHash(int, &ComplexName,function(a) return(tonumber(a)) end)

-- CC = terralib.global(ComplexName,{ name = "foo", x = 1.0, y=2.0})

NN=3
terra doAdd()
   var b : hashIntToComplex
   for i=1,NN do
      var c : &ComplexName = [&ComplexName](C1.malloc(sizeof(ComplexName)))
      c.name ,c.x,c.y="foo",1.0,2.0
      b:add(i,c)
   end
   return(&b)
   
end

terra doGet(b:&hashIntToComplex)
   var d : &ComplexName
   for i=1,NN do
      d= b:get(i)
      -- C1.free(d)
   end
   C.printf("Name = %s, Real = %f, Imag=%f\n",d.name, d.x,d.y)
end


-- fails miserable for string keys ....
-- because the stored keys are numbers ....
terra doIter(b: &hashIntToComplex)
   var p =b:makeIter()
   while p:hasNext() do
      var v,k = p:next()
      C.printf("%d %s\n",k,v.name)
   end
end

require("os")
require("string")

function testtime()
   local x = os.clock()
   local s
   local b =   doAdd()
   print(string.format("elapsed time: %.2f\n", os.clock() - x))
   x = os.clock()
   doGet(b)
   doIter(b)
   print(string.format("elapsed time: %.2f\n", os.clock() - x))
end

testtime()

-- djb2hash:disas()
-- hashfunctions.djb2hash:disas()
terra Mos()
   var c: ComplexName = { name = "foo", x = 1.0, y=2.0}
   var b : hashStrToComplex
   b:add("foo",&c)
   var d = b:get("foo")
   -- var b : hashIntToComplex
   -- b:add(1,&c)
   -- var d = b:get(1)

   if d~= nil then
      C.printf("Name = %s, Real = %f, Imag=%f\n",d.name, d.x,d.y)
   end
   C.printf("Name = %s, Real = %f, Imag=%f\n",c.name, c.x,c.y)
end
-- Mos()
