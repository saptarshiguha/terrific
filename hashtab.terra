C = terralib.includec("stdio.h")
C1 = terralib.includec("stdlib.h")
ffi = require("ffi")
local hashfunctions = terralib.includecstring [[	
unsigned long djb2hash(const char *str)
{
    unsigned long hash = 5381;
    int c;
    while ( (c = *str++))
        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
    return hash;
}
		 ]]

terra djb2hash(a : &int8) : uint64
   var hash: uint64 = 5381
   var c = @a
   var i :int8 = 0 -- typing makes a difference
   while c~=0 do
      hash = (( hash << 5)+hash) + c
      i = i+1
      c = @(a + i)
   end
   return hash
end

local function ptable(w)
   for key,value in pairs(w) do print(key,value) end
end

function makeHash(kType,vType,hashfunction)
   local b = {}
   local function add(self,key,value)
      b[hashfunction(key)] = value
   end
   local function exists(self,key)
      if b[hashfunction(key)]~= nil then
   	 return true
      else
   	 return false
      end
   end
   local function get(self,key)
      return terralib.cast(vType,b[hashfunction(key)])
   end
   local function delete(self,key)
      b[hashfunction(key)] = nil
   end
   local struct Hash   {   }
   Hash.methods.add =  terralib.cast( {&Hash,kType,vType} -> {}, add)
   Hash.methods.get = terralib.cast( {&Hash,kType} -> {vType}, get)
   Hash.methods.exists  = terralib.cast( {&Hash,kType} -> {bool}, exists)
   Hash.methods.del = terralib.cast( {&Hash,kType} -> {}, delete)
   return Hash
end

struct ComplexName
{
   name: &int8;
   x : double;
   y : double;
}

function strhash(s )
   -- return tonumber(hashfunctions.djb2hash(s))
   return tonumber(djb2hash(s))
end

hashStrToComplex = makeHash(rawstring, &ComplexName,strhash)
hashIntToComplex = makeHash(int, &ComplexName,function(a) return(tonumber(a)) end)

-- CC = terralib.global(ComplexName,{ name = "foo", x = 1.0, y=2.0})

NN=10
terra doAdd()
   var b : hashIntToComplex
   for i=1,NN do
      var c : &ComplexName = [&ComplexName](C1.malloc(sizeof(ComplexName)))
      c.name ,c.x,c.y="foo",1.0,2.0
      b:add(i,c)
   end
   return(&b)
end

terra doGet(b:&hashIntToComplex)
   var d : &ComplexName
   for i=1,10 do
      d= b:get(i)
      C1.free(d)
   end
   -- C.printf("Name = %s, Real = %f, Imag=%f\n",d.name, d.x,d.y)
end


terra doHash1()
   var f="foo"
   var s : uint64
   for i=1,50000000 do
       s=djb2hash(f)
   end
   return(s)
end
terra doHash2()
   var f="foo"
   var s : uint64
   for i=1,50000000 do
       s=hashfunctions.djb2hash(f)
   end
   return(s)
end

require("os")
require("string")

function testtime()
   local x = os.clock()
   local s
   s=doHash1()
   print(string.format("elapsed time: %.2f\n", os.clock() - x))
   x = os.clock()
   s=doHash2()
   print(s)
   -- doGet(b)
   print(string.format("elapsed time: %.2f\n", os.clock() - x))
end

testtime()

djb2hash:disas()
hashfunctions.djb2hash:disas()
terra Mos()
   var c: ComplexName = { name = "foo", x = 1.0, y=2.0}
   var b : hashStrToComplex
   b:add("foo",&c)
   var d = b:get("foo")
   -- var b : hashIntToComplex
   -- b:add(1,&c)
   -- var d = b:get(1)

   if d~= nil then
      C.printf("Name = %s, Real = %f, Imag=%f\n",d.name, d.x,d.y)
   end
   C.printf("Name = %s, Real = %f, Imag=%f\n",c.name, c.x,c.y)
end
-- Mos()
