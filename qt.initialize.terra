require 'qtcore'
require 'qtgui'
pthread = terralib.includec("pthread.h")
terralib.linklibrary("libQtCore.so")
local ifd = global(int)
local ofd = global(int)
local fired=global(int,0)
local qtwriterthread = global(pthread.pthread_t)
local App = nil
local mu = {}
function processQTEvents(x)
   QCoreApplication.processEvents()
end
terra QTEventLoopHandler(data : &uint8)
   var buf : uint8[16]
   unistd.read(ifd,buf,16)
   processQTEvents()
   fired=0
end
terra mywriter(data : &uint8) : &uint8
   var buf : uint8[16];
   while true do
      unistd.usleep(10000)
      if fired == 0  then
	 fired = 1
	 buf[0]=0
	 var s = unistd.write(ofd, buf, 1);
      end
   end
end
terra QTEventLoopInit()
   var fds : int[2]
   if unistd.pipe(fds) == 0  then
      ifd,ofd = fds[0],fds[1]
      Rinternals.addInputHandler(R.constants.InputHandlers,ifd,QTEventLoopHandler,31)
      Rinternals.setCStackLimit(-1)
      pthread.pthread_create(&qtwriterthread,nil,mywriter,nil);
   end
end
function qtinit(a)
   App = QApplication(1, {"qtbase", "-nograb"})
   QTEventLoopInit()
end

